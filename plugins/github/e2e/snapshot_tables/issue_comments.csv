id,issue_id,body,user_id,created_date
github:GithubIssue:1:409800144,github:GithubIssue:1:346842831,"""这里freeSignal和idleWorkers的数量是绝对匹配的，也就是说，只要freeSignal有值那么idleWorkers里肯定有可用worker可以取出来，putWorker就是把可用worker放回idleWorkers，每次都会塞一个值进freeSignal，还有每次从idleWorkers里取一个worker都要取出freeSignal对应的一个值，不存在有可用worker却被freeSignal阻塞""",github:GithubUser:1:7496278,2018-08-02T04:13:09.000+00:00
github:GithubIssue:1:410141732,github:GithubIssue:1:347255859,"""切片如下\r\n\r\n这里等待锁\r\n9913 @ 0x42c73a 0x42c7ee 0x43cf64 0x43cc7d 0x46dfe8 0x7b28e0 0x7b2be5 0x4591f1\r\n#\t0x43cc7c\tsync.runtime_SemacquireMutex+0x3c\t\t\t\tE:/go/src/runtime/sema.go:71\r\n#\t0x46dfe7\tsync.(*Mutex).Lock+0x107\t\t\t\t\tE:/go/src/sync/mutex.go:134\r\n#\t0x7b28df\tmp/vendor/github.com/panjf2000/ants.(*Pool).putWorker+0x6f\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:229\r\n#\t0x7b2be4\tmp/vendor/github.com/panjf2000/ants.(*Worker).run.func1+0x54\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/worker.go:53\r\n\r\n\r\n//这里占用了锁无法释放\r\n1 @ 0x42c73a 0x42c7ee 0x404212 0x403ecb 0x7b27df 0x7b23e2 0x7f694a 0x7f68e1 0x4591f1\r\n#\t0x7b27de\tmp/vendor/github.com/panjf2000/ants.(*Pool).getWorker+0x22e\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:199\r\n#\t0x7b23e1\tmp/vendor/github.com/panjf2000/ants.(*Pool).Submit+0x61\t\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:125\r\n\r\n\r\n""",github:GithubUser:1:13118848,2018-08-03T04:33:23.000+00:00
github:GithubIssue:1:410143221,github:GithubIssue:1:347255859,"""加了锁之后有下标溢出了。。。\r\npanic: runtime error: index out of range\r\n\r\ngoroutine 7 [running]:\r\nmp/vendor/github.com/panjf2000/ants.(*Pool).getWorker(0xc4200b6460, 0xc4202a6e01)\r\n\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:213 +0x2ce\r\nmp/vendor/github.com/panjf2000/ants.(*Pool).Submit(0xc4200b6460, 0xc4223d47d0, 0x0, 0x0)\r\n\tF:/gowork/src/mp/vendor/github.com/panjf2000/ants/pool.go:125 +0x62\r\n""",github:GithubUser:1:13118848,2018-08-03T04:46:13.000+00:00
github:GithubIssue:1:410147487,github:GithubIssue:1:347255859,"""@lovelly 我查了源码，怎么行数和你说的有点对不上，你的代码更新到最新了吗？""",github:GithubUser:1:7496278,2018-08-03T05:21:03.000+00:00
github:GithubIssue:1:410170764,github:GithubIssue:1:347255859,"""是最新的代码，我有添加一些print 所以行数不一样，这确实是一个bug 9913个协程阻塞在了 putWorker 很久很久。，。。。""",github:GithubUser:1:13118848,2018-08-03T07:33:21.000+00:00
github:GithubIssue:1:410173358,github:GithubIssue:1:347255859,"""![image](https://user-images.githubusercontent.com/13118848/43630582-44f48000-9733-11e8-936d-9cb0d4145204.png)\r\n 我idleWorkers 为空的， 但是我有n个协程阻塞在了 204行的\t<-p.freeSignal， 这时候来了一个worker被放入idleWorkers， 很巧的是一个协程在putWorker结束锁后，在190行的p.lock.Lock()拿到了锁，这时候 n := len(idleWorkers) - 1 结果是0 这个协程很高兴的进入了接下来的else分支, 然而不幸发生了，p.freeSignal的信号确被早已等在 204行的若干个协程中的一个拿走了， 那么 可怜的协程拿到了锁， 确无法等到 p.freeSignal  p.freeSignal要拿到锁才能产生信号， 然后就。，。。""",github:GithubUser:1:13118848,2018-08-03T07:44:32.000+00:00
github:GithubIssue:1:410204870,github:GithubIssue:1:347255859,"""@lovelly 检查了一下，的确可能会有这个问题，这两天我会修复；\r\n另外，我测试的时候试过1000w的量都没发现过这个问题，可能是我每个任务的执行时间太短了，所以我想问下你的任务量有多大以及每个任务的耗时大概是多少？""",github:GithubUser:1:7496278,2018-08-03T09:51:15.000+00:00
github:GithubIssue:1:410205295,github:GithubIssue:1:347255859,"""我任务耗时从0秒到60秒之间。。。""",github:GithubUser:1:13118848,2018-08-03T09:53:00.000+00:00
github:GithubIssue:1:410267195,github:GithubIssue:1:347255859,"""@lovelly 应该已经修复了，可以再试试""",github:GithubUser:1:7496278,2018-08-03T14:15:45.000+00:00
github:GithubIssue:1:410290418,github:GithubIssue:1:346842831,"""具体问题可以看 #6 """,github:GithubUser:1:7496278,2018-08-03T15:32:00.000+00:00
github:GithubIssue:1:411342200,github:GithubIssue:1:348630179,"""@huiwq1990 谢谢指出，今天会修复这个问题。""",github:GithubUser:1:7496278,2018-08-08T09:17:30.000+00:00
github:GithubIssue:1:411369513,github:GithubIssue:1:348630179,"""@huiwq1990 应该解决了，可以再试试""",github:GithubUser:1:7496278,2018-08-08T11:06:55.000+00:00
github:GithubIssue:1:411965696,github:GithubIssue:1:348630179,"""嗯，解决了""",github:GithubUser:1:4555057,2018-08-10T03:35:53.000+00:00
github:GithubIssue:1:411969260,github:GithubIssue:1:348630179,"""@huiwq1990 好的，那我关掉这个issue了。""",github:GithubUser:1:7496278,2018-08-10T04:06:04.000+00:00
github:GithubIssue:1:418287926,github:GithubIssue:1:356703393,"""会导致很多任务长时间在阻塞，至于cpu飙升应该不会""",github:GithubUser:1:7496278,2018-09-04T08:40:06.000+00:00
github:GithubIssue:1:418290090,github:GithubIssue:1:356703393,"""所以应该在goroutine中调用submit 否则会阻塞主任务""",github:GithubUser:1:11763614,2018-09-04T08:47:39.000+00:00
github:GithubIssue:1:418293975,github:GithubIssue:1:356703393,"""不是的，如果每一个submit都用一个goroutine那不就违背初衷了吗，这样的话你有多少个任务还是要启动多少个原生goroutine。""",github:GithubUser:1:7496278,2018-09-04T09:00:55.000+00:00
github:GithubIssue:1:418297020,github:GithubIssue:1:356703393,"""// Submit submits a task to this pool.\r\nfunc (p *Pool) Submit(task f) error {\r\n\tif len(p.release) > 0 {\r\n\t\treturn ErrPoolClosed\r\n\t}\r\n\tp.getWorker().task <- task\r\n\treturn nil\r\n}\r\n我是觉得p.getWorker()  阻塞不太好 ，这样主任务和pool没有彻底隔离""",github:GithubUser:1:11763614,2018-09-04T09:11:37.000+00:00
github:GithubIssue:1:425014962,github:GithubIssue:1:364361014,"""我晚上回去就打一下新的tag，完了我再给你回一个邮件\r\n\r\nedcismybrother <notifications@github.com> 于2018年9月27日周四 下午4:32写道：\r\n\r\n> 鄙人现在在弄dep依赖管理，有用到你写的ants项目，可是你好像忘记打最新的tag了。最新的tag\r\n> 3.6是指向ed55924这个提交，git上的最新代码是af376f1b这次提交，两次提交都隔了快5个月了，看到的话，麻烦打一个最新的tag吧。（手动可怜）\r\n>\r\n> —\r\n> You are receiving this because you are subscribed to this thread.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/panjf2000/ants/issues/12>, or mute the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AHJiVu1xmx5uoFGBcSu6te_iHFwf7IPEks5ufI0egaJpZM4W8KCS>\r\n> .\r\n>\r\n""",github:GithubUser:1:7496278,2018-09-27T09:00:40.000+00:00
github:GithubIssue:1:425018770,github:GithubIssue:1:356703393,"""我觉得这个会导致cpu上升。调用Submit时，如果没有多余的worker，会一直进入这个死循环\r\n```\t\t\r\nfor {\r\n\t\t\tp.lock.Lock()\r\n\t\t\tidleWorkers = p.workers\r\n\t\t\tl := len(idleWorkers) - 1\r\n\t\t\tif l < 0 {\r\n\t\t\t\tp.lock.Unlock()\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tw = idleWorkers[l]\r\n\t\t\tidleWorkers[l] = nil\r\n\t\t\tp.workers = idleWorkers[:l]\r\n\t\t\tp.lock.Unlock()\r\n\t\t\tbreak\r\n\t\t}\r\n```\r\n一直会continue，直到有空闲的worker，这样会阻塞调用Submit的goroutine.""",github:GithubUser:1:12890888,2018-09-27T09:13:01.000+00:00
github:GithubIssue:1:425061837,github:GithubIssue:1:356703393,"""![snip20180927_3](https://user-images.githubusercontent.com/12890888/46144182-c4efe200-c28e-11e8-8e69-ffd4502e3b9e.png)\r\n\r\ncpu占用率一直接近100%\r\n\r\n![snip20180927_4](https://user-images.githubusercontent.com/12890888/46144221-ddf89300-c28e-11e8-985b-48437eb20cdc.png)\r\n""",github:GithubUser:1:12890888,2018-09-27T11:53:26.000+00:00
github:GithubIssue:1:425062926,github:GithubIssue:1:364361014,"""tag更新了，v3.7\r\n\r\nAndy Pan <panjf2000@gmail.com> 于2018年9月27日周四 下午5:00写道：\r\n\r\n> 我晚上回去就打一下新的tag，完了我再给你回一个邮件\r\n>\r\n> edcismybrother <notifications@github.com> 于2018年9月27日周四 下午4:32写道：\r\n>\r\n>> 鄙人现在在弄dep依赖管理，有用到你写的ants项目，可是你好像忘记打最新的tag了。最新的tag\r\n>> 3.6是指向ed55924这个提交，git上的最新代码是af376f1b这次提交，两次提交都隔了快5个月了，看到的话，麻烦打一个最新的tag吧。（手动可怜）\r\n>>\r\n>> —\r\n>> You are receiving this because you are subscribed to this thread.\r\n>> Reply to this email directly, view it on GitHub\r\n>> <https://github.com/panjf2000/ants/issues/12>, or mute the thread\r\n>> <https://github.com/notifications/unsubscribe-auth/AHJiVu1xmx5uoFGBcSu6te_iHFwf7IPEks5ufI0egaJpZM4W8KCS>\r\n>> .\r\n>>\r\n>\r\n""",github:GithubUser:1:7496278,2018-09-27T11:57:31.000+00:00
github:GithubIssue:1:425066089,github:GithubIssue:1:356703393,"""@liyonglion 这个例子看起来有点极端，因为只有两个任务，pool容量是1，所以剩下那个不断在自己加锁解锁导致cpu忙，如果是多个竞争的大部分是block状态，应该不会出现这种cpu满的情况，不然你把例子改改？增加提交的任务数再看看，看看还会不会出现这种情况。""",github:GithubUser:1:7496278,2018-09-27T12:07:30.000+00:00
github:GithubIssue:1:425288734,github:GithubIssue:1:356703393,"""@panjf2000  ants比较适合做“短期”任务，如果存在大量的“长期”任务，很有可能导致死循环。为什么不block当前Submit的“线程”？""",github:GithubUser:1:12890888,2018-09-28T01:09:40.000+00:00
github:GithubIssue:1:425293042,github:GithubIssue:1:356703393,"""@liyonglion 之前有用过chan阻塞等待，但是导致了一个死锁问题：#6，后来才改成这种形式。所以我说的增加submit的任务数再测试之后也是cpu 100%吗？这个问题我现在暂时没想到比较好的解决办法，我再想想，或者你有没有比较好的想法？可以提个pr。""",github:GithubUser:1:7496278,2018-09-28T01:37:17.000+00:00
github:GithubIssue:1:425331360,github:GithubIssue:1:364361014,"""@panjf2000 可以的，谢谢啦""",github:GithubUser:1:29452204,2018-09-28T06:05:58.000+00:00
github:GithubIssue:1:425409255,github:GithubIssue:1:356703393,"""@panjf2000  我提交了一个pr，你看下是否合理？我自己跑了上面的用例，没有问题。效率方面我还没有具体测试。""",github:GithubUser:1:12890888,2018-09-28T11:41:08.000+00:00
github:GithubIssue:1:425423023,github:GithubIssue:1:356703393,"""@liyonglion 我看修改的代码应该是正确的，但是有两个问题：\r\n1. 要正确测试你pr，你要把ants_test.go里import ants的路径改成你自己的路径；\r\n2.你现在只修改了pool.go的代码，麻烦把pool_func.go里相应的地方也优化一下。""",github:GithubUser:1:7496278,2018-09-28T12:41:27.000+00:00
github:GithubIssue:1:439792581,github:GithubIssue:1:382039050,"""GOMAXPROCS你可以理解成是G-P-M模型中的M的数量，也就是最大并行数。""",github:GithubUser:1:7496278,2018-11-19T07:10:47.000+00:00
github:GithubIssue:1:439793939,github:GithubIssue:1:381941219,"""release的确有这个问题，目前还没有比较好的办法，只是等待定时销毁的那个goroutine去释放内存，你要是有兴趣可以再想想有没有更好的办法，可以提个pr""",github:GithubUser:1:7496278,2018-11-19T07:18:05.000+00:00
github:GithubIssue:1:440207809,github:GithubIssue:1:382574800,"""https://github.com/panjf2000/ants/blob/711dbdb7a222771ce15aaee1bb7b7c6e9731f208/pool.go#L119""",github:GithubUser:1:5668717,2018-11-20T09:41:24.000+00:00
github:GithubIssue:1:440263871,github:GithubIssue:1:382574800,"""这里可以讨论下，是否可以在任务函数里通过闭包的形式，将结果存入channel，满足你的需求？""",github:GithubUser:1:7496278,2018-11-20T12:56:13.000+00:00
github:GithubIssue:1:440500490,github:GithubIssue:1:382574800,"""> 这里可以讨论下，是否可以在任务函数里通过闭包的形式，将结果存入channel，满足你的需求？\r\n\r\n可以的。但不仅仅如此，最重要的是想得到哪条消息失败了，方便进行下次延时处理或丢回队列。""",github:GithubUser:1:5668717,2018-11-21T02:00:22.000+00:00
github:GithubIssue:1:440541883,github:GithubIssue:1:382574800,"""目前可以通过参数来传入处理失败的chan\r\n\r\ntype msg struct {\r\n……\r\nFailed chan<- *msg\r\n}\r\n\r\n// payload == &msg\r\npool,_:= NewPoolWithFunc(10,func(payload interface{}) error{\r\n……\r\n// 失败的话payload 发送到 Failed chan\r\n})\r\n\r\npool.Serve(msg)""",github:GithubUser:1:7931755,2018-11-21T05:57:51.000+00:00
github:GithubIssue:1:440605531,github:GithubIssue:1:382574800,"""> 目前可以通过参数来传入处理失败的chan\r\n> \r\n> type msg struct {\r\n> ……\r\n> Failed chan<- *msg\r\n> }\r\n> \r\n> // payload == &msg\r\n> pool,_:= NewPoolWithFunc(10,func(payload interface{}) error{\r\n> ……\r\n> // 失败的话payload 发送到 Failed chan\r\n> })\r\n> \r\n> pool.Serve(msg)\r\n\r\n我目前的做法是没有用 `NewPoolWithFunc()`，而是用的 `ants.NewPool()`，控制整个服务只有一个`pool`，所有的任务都是从大`pool`里取：\r\n\r\n```\r\nfunc (w *Worker) Register(fn func() error, opts ...Option) error {\r\n\t// w.Workers = append(w.Workers, runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name())\r\n\top := Op{}\r\n\top.applyOpts(opts)\r\n\r\n\tif op.GoroutineSize <= 1 {\r\n\t\treturn w.Pool.Submit(fn)\r\n\t}\r\n\r\n\tfor i := 0; i < op.GoroutineSize; i++ {\r\n\t\tw.Pool.Submit(fn)\r\n\t}\r\n\r\n\treturn nil\r\n}\r\n```\r\n想基于这种方式来处理失败任务的逻辑。可有方式实现？\r\n\r\n还有任务依赖也是我面临的问题，比如A任务依赖其它N个任务执行完成或者必须执行成功/失败后，触发A任务。当然解决这个问题并非必须靠`ants`框架层面实现，也可以业务实现，如果`ants`框架层面能解决是最完美的。\r\n\r\n不知道你怎么认为。\r\n""",github:GithubUser:1:5668717,2018-11-21T10:01:45.000+00:00
github:GithubIssue:1:440876192,github:GithubIssue:1:382574800,"""错误返回，按照ants的设计，其实应该是异步的，目前没办法直接return error到调用的函数里，所以我觉得就算是处理也应该是异步的方式；至于任务依赖，目前想到的有两种办法：1.回调函数；2.消息通知(通过channel或消息队列)，至于是不是要把这些复杂的逻辑加到ants里，有待商榷，或者你也可以推一个pr，大家一起探讨下~~""",github:GithubUser:1:7496278,2018-11-22T01:09:56.000+00:00
github:GithubIssue:1:442366878,github:GithubIssue:1:381941219,"""在 pool里面加上一个 waitgroup，每次 启动一个 work，调用 waitgroup.Add()，协程执行完了就执行waitgroup.Done()。在release时候调用waitgroup.Wait()。最后再回收空闲 worker。不过b如果 worker 对于的 func 执行时间过长，会导致release一直等待。""",github:GithubUser:1:32898629,2018-11-28T08:48:17.000+00:00
github:GithubIssue:1:445462719,github:GithubIssue:1:388907811,"""你的go版本是多少？""",github:GithubUser:1:7496278,2018-12-08T14:20:26.000+00:00
github:GithubIssue:1:445496131,github:GithubIssue:1:388907811,"""go version go1.11.1 darwin/amd64\r\n\r\n我也尝试了将几个参数调小一点，结果都是 Semaphore 和 AntsPool 量级上都是差不多的""",github:GithubUser:1:720086,2018-12-08T22:56:54.000+00:00
github:GithubIssue:1:445815378,github:GithubIssue:1:388907811,"""嗯，的确是一个量级。\r\nants的优势是：\r\n1. 内存消耗会小(并发量大的时候几乎可以节省一半的内存量)；\r\n2. goroutine常驻内存（定时清理长时间空置的goroutine，按最后使用时间排序，最久未使用的goroutine最先被清理，进一步降低资源消耗）；\r\n3. ants pool更加灵活可控，可动态调整pool size、手动销毁pool；\r\n4. 还有各类方法获取正在运行的goroutine数量、可用的goroutine数量，使并发程序更精确可控；\r\n......""",github:GithubUser:1:7496278,2018-12-10T13:30:04.000+00:00
github:GithubIssue:1:446447291,github:GithubIssue:1:388907811,"""好的，怎么样测试内存消耗呢？按我理解大家活跃的 go routines 是一样的数目，为什么 ants 的内存消耗会小呢？""",github:GithubUser:1:720086,2018-12-12T03:18:44.000+00:00
github:GithubIssue:1:446453643,github:GithubIssue:1:388907811,"""加上benchmem=true参数；至于为什么内存会更小，是因为在pool里的goroutines是常驻内存的，新的任务是复用goroutine的，而用sema的话只是限制了活跃的goroutine数量，并没有复用，新的任务还是会生成新的goroutine。""",github:GithubUser:1:7496278,2018-12-12T03:58:29.000+00:00
github:GithubIssue:1:456022133,github:GithubIssue:1:401277739,"""合理的需求，可以加。我这两天加下。""",github:GithubUser:1:7496278,2019-01-21T10:21:24.000+00:00
github:GithubIssue:1:456022560,github:GithubIssue:1:401277739,"""你要有兴趣也可以自己做，然后提个PR。""",github:GithubUser:1:7496278,2019-01-21T10:22:39.000+00:00
github:GithubIssue:1:459948887,github:GithubIssue:1:405951301,"""@jiashiwen \r\nIt works on my side, pls make sure that you run the example on top of the latest ants code, thanks.""",github:GithubUser:1:7496278,2019-02-02T09:03:51.000+00:00
github:GithubIssue:1:468919580,github:GithubIssue:1:413968505,"""不会的，incRunning操作总是在比较大小之后才发生的。""",github:GithubUser:1:7496278,2019-03-02T13:14:05.000+00:00
github:GithubIssue:1:471299071,github:GithubIssue:1:419183961,"""server接收的并发请求量有多大？""",github:GithubUser:1:7496278,2019-03-10T13:18:01.000+00:00
github:GithubIssue:1:471869506,github:GithubIssue:1:419268851,"""加锁后资源消耗会增加，性能会下降很多，所以是加锁确保池数量还是不加锁保证性能呢？""",github:GithubUser:1:29243953,2019-03-12T06:06:39.000+00:00
